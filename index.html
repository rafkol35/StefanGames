<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>StefanGames Game1</title>
    <style>
        body {
            background: #fff;
            padding: 0;
            margin: 0;
            overflow: hidden;
            font-family: georgia;
            text-align: center;
        }
        h1 {
        }

        a {
            color: skyblue;
        }

        #stats { position: absolute; top: 0; left: 0; }
        #stats #fps { background: transparent !important; }
        #stats #fps #fpsText { color: #abc !important; }
        #stats #fps #fpsGraph { display: none; }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    
</head>
<body>
    <script src="js/three.min.js"></script>
    <script src="js/stats.min.js"></script>    

    <script>
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (mousePressed && !draggedCubic) {
                var diffangley = (((mouse.x - mouseLast.x) * 90) * Math.PI / 180);
                var diffanglex = (((mouseLast.y - mouse.y) * 90) * Math.PI / 180);
                rotateAroundWorldAxis(pivot, new THREE.Vector3(0, 1, 0), diffangley);
                rotateAroundWorldAxis(pivot, new THREE.Vector3(1, 0, 0), diffanglex);
                pivot.updateMatrix();
                pivot.updateMatrixWorld();

                var i = 0;
                for (var x = -1 ; x <= 1 ; ++x) {
                    for (var y = -1 ; y <= 1 ; ++y) {
                        for (var z = -1 ; z <= 1 ; ++z) {
                            var cp = pivot.localToWorld(new THREE.Vector3(x, y, z));
                            cubics[i].setRotationFromMatrix(pivot.matrixWorld);
                            cubics[i].position.set(cp.x, cp.y, cp.z);
                            ++i;
                        }
                    }
                }
            }
            else 
            {
            }
            mouseLast.set(mouse.x,mouse.y);
        }

        function onDocumentMouseDown(event) {
            event.preventDefault();
            mousePressed = true;
            mouseClickPos.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseClickPos.y = -(event.clientY / window.innerHeight) * 2 + 1;
            mouseLast = mouseClickPos;

            raycasterTouch.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(cubics);

            if (intersects.length > 0) {
                draggedCubic = intersects[0].object;
                console.log(draggedCubic.position);

                var ccp = new THREE.Vector3(draggedCubic.position.x, draggedCubic.position.y, draggedCubic.position.z);
                var cp = pivot.worldToLocal(ccp);
                cp.round();
                console.log(cp);
            }
        }
        function onDocumentMouseUp(event) {
            event.preventDefault();
            mousePressed = false;
            draggedCubic = null;
        }

        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
        window.addEventListener('resize', onWindowResize, false);

        var mousePressed = false;
        var mouse = new THREE.Vector2(), INTERSECTED;
        var mouseClickPos = new THREE.Vector2();
        var mouseLast = new THREE.Vector2();
        var raycaster = new THREE.Raycaster();
        var raycasterTouch = new THREE.Raycaster();

        var clock = new THREE.Clock();

        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        //var camera = new THREE.OrthographicCamera(-1.2,1.2, 1,-1, 0.1, 1000);
        //var camera = new THREE.OrthographicCamera(window.innerWidth / -200, window.innerWidth / 200, window.innerHeight / 200, window.innerHeight / -2000, -500, 1000);

        var light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 0, 5).normalize();
        scene.add(light);

        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xf0f0f0);
        document.body.appendChild(renderer.domElement);

        // STATS
        var container, stats;
        container = document.createElement('div');
        document.body.appendChild(container);
        var stats = new Stats();
        container.appendChild(stats.domElement);

        var pivot = new THREE.Object3D();
        var draggedCubic = null;
        var cubics = new Array(27);
        var i = 0;
        for (var x = -1 ; x <= 1 ; ++x) {
            for (var y = -1 ; y <= 1 ; ++y) {
                for (var z = -1 ; z <= 1 ; ++z) {
                    //if (x == 0 && y == 0 && z == 0) {
                    //    cubics[i] = middlecube;
                    //    i++;
                    //    continue;
                    //}
                    //if (z != 0) {
                    //    i++;
                    //    continue;
                    //}

                    var cube = createCubic(new THREE.Vector3(x, y, z));
                    scene.add(cube);
                    cubics[i] = cube;
                    i++;
                }
            }
        }

        camera.position.set(0, 0, 5);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        var render = function () {
            if (!mousePressed) {
                raycaster.setFromCamera(mouse, camera);
                var intersects = raycaster.intersectObjects(cubics);

                if (intersects.length > 0) {
                    if (INTERSECTED != intersects[0].object) {
                        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                        INTERSECTED = intersects[0].object;
                        INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                        INTERSECTED.material.emissive.setHex(0x444444);
                    }
                } else {
                    if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                    INTERSECTED = null;
                }
            }
            requestAnimationFrame(render);

            renderer.render(scene, camera);
            stats.update();
        };

        render();

        function createCubic(p) {
            var map1 = THREE.ImageUtils.loadTexture('rbn.png');
            var geometry = new THREE.BoxGeometry(1, 1, 1);

            var cls = [];
            cls.push(new THREE.Color(0xffffff));
            cls.push(new THREE.Color(0xff0000));
            cls.push(new THREE.Color(0x00ff00));
            cls.push(new THREE.Color(0x0000ff));
            cls.push(new THREE.Color(0xffff00));
            cls.push(new THREE.Color(0xdd8800));

            for (var i = 0 ; i < 6 ; ++i) {
                //for (var f = 0 ; f < 2 ; ++f) {
                //}
                geometry.faces[i * 2].vertexColors[0] = cls[i];
                geometry.faces[i * 2].vertexColors[1] = cls[i];
                geometry.faces[i * 2].vertexColors[2] = cls[i];

                geometry.faces[i * 2 + 1].vertexColors[0] = cls[i];
                geometry.faces[i * 2 + 1].vertexColors[1] = cls[i];
                geometry.faces[i * 2 + 1].vertexColors[2] = cls[i];
            }
            //geometry.faces[0].vertexColors[0] = new THREE.Color(0xffffff);
            //geometry.faces[0].vertexColors[1] = new THREE.Color(0xff0000);
            //geometry.faces[0].vertexColors[2] = new THREE.Color(0xff0000);
            //geometry.faces[1].vertexColors[0] = new THREE.Color(0xffffff);
            //geometry.faces[1].vertexColors[1] = new THREE.Color(0xff0000);
            //geometry.faces[1].vertexColors[2] = new THREE.Color(0xff0000);

            //for (var i = 0 ; i < 1 ; ++i) {
                //geometry.faceVertexUvs[0][0][0] = new THREE.Vector2(0, 0);
                //geometry.faceVertexUvs[0][0][1] = new THREE.Vector2(0, 0.2);
                //geometry.faceVertexUvs[0][0][2] = new THREE.Vector2(0.2, 0);
                                       
                //geometry.faceVertexUvs[0][1][0] = new THREE.Vector2(0, 0);
                //geometry.faceVertexUvs[0][1][1] = new THREE.Vector2(0, 2);
                //geometry.faceVertexUvs[0][1][2] = new THREE.Vector2(2, 0);
            //}
            var material = new THREE.MeshLambertMaterial({ map: map1, color: 0xffffff, vertexColors: THREE.VertexColors });
            var cube = new THREE.Mesh(geometry, material);
            cube.position.set(p.x,p.y,p.z);// = position;
            return cube;
        };

        // Rotate an object around an arbitrary axis in world space       
        function rotateAroundWorldAxis(object, axis, radians) {
            var rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationAxis(axis.normalize(), radians);
            rotationMatrix.multiply(object.matrix);                       // pre-multiply
            object.matrix = rotationMatrix;
            object.rotation.setFromRotationMatrix(object.matrix);
        }

    </script>
</body>
</html>